[main]
# FILTER KONFIG
shiro.loginUrl = /Login.jsf
filterChainResolver.globalFilters = invalidRequest


# Eigene Filter deklarieren
meinFilter = de.marcel.restaurant.web.security.ModifiedAuthenticationFilter
meinFilter.loginUrl = /Login.jsf

# CACHING
cacheManager = org.apache.shiro.cache.MemoryConstrainedCacheManager
# Okay für JVM Anwendungen die auf einem Server laufen, bei Clustern: ClusteredCacheManager

# DATASOURCE
ds = org.apache.shiro.jndi.JndiObjectFactory
ds.resourceName = java:jboss/datasources/RestaurantAppDSmariaDB_auth


# REALM
# jdbcRealm = shiroTestClasses.MyJdbcRealm
jdbcRealm = org.apache.shiro.realm.jdbc.JdbcRealm
jdbcRealm.dataSource = $ds
jdbcRealm.authenticationQuery=SELECT password, salt FROM users WHERE users.email=?
jdbcRealm.userRolesQuery=SELECT gruppen.groupname FROM gruppen WHERE gruppen.email=?
;# Permissions werden nicht genutzt, nur PW und Role
jdbcRealm.permissionsLookupEnabled=false
;# Die Einstellung bewirkt, dass er bei der Passwort Query in der zweiten Spalte nach dem Salt sucht
jdbcRealm.saltStyle=COLUMN



# SECURITY MANAGER
securityManager.cacheManager = $cacheManager
securityManager.realm = $jdbcRealm


# CREDENTIAL ENTSCHLÜSSELUNG (Verschlüsselung geschieht in der App)
credentialsMatcher = org.apache.shiro.authc.credential.HashedCredentialsMatcher
credentialsMatcher.storedCredentialsHexEncoded = false
# This next property is only needed in Shiro 1.0\.  Remove it in 1.1 and later:
credentialsMatcher.hashSalted = true
# Iterationen: In Prod. mit 1024 versuchen
# Anpassen in LoginController
credentialsMatcher.hashIterations = 1
credentialsMatcher.hashAlgorithmName = SHA-256
jdbcRealm.credentialsMatcher = $credentialsMatcher
;authc.enabled = true

[urls]
# FILTERING
/Login.jsf = meinFilter
/logout = logout
# /Login.jsf = ssl[443]


########## Restaurant Security Config ################
/UserList.jsf = anon
/UserCreate.jsf = anon
/javax.faces.resource/bootstrap/* = anon
/javax.faces.resource/* = anon
# Websockets Security aus
/javax.faces.push/** = anon

/*= meinFilter
